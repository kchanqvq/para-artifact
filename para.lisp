(defpackage #:prf
  (:use #:cl #:sb-c #:sb-ext #:iter #:sb-sys #:fare-memoization
        #:sb-vm #:sb-thread #:sb-kernel #:sb-cltl2)
  (:export #:bfs #:pfun #:recurse #:hole #:arities #:list-of #:tree-of #:tree-1-of
           #:random-search #:defproblem #:solve-problem
           #:print-pfun #:print-haskell #:call-pfun
           #:*problems* #:*results* #:*tests* #:*examples*
           #:generate-examples #:save-table #:load-table #:find-result
           #:with-temporary-file)
  (:shadowing-import-from #:metabang-bind #:bind)
  (:local-nicknames (#:a #:alexandria) (#:t #:trivia) (#:s #:scaena)
                    (#:o #:objet-petit-a)))
(uiop:define-package #:prf-user
    (:mix #:fare-memoization #:prf #:cl #:iter)
  (:export #:nzp #:count-odd #:inc #:div2 #:zero #:count-odd))
(in-package #:prf)
(add-package-local-nickname "U" "PRF-USER")
;;; Utilities
(eval-when (:compile-toplevel :load-toplevel :execute)
  (setf iterate::*always-declare-variables* t))
(defmacro klet (((name arglist &body cont)) &body body)
  `(flet ((,name ,arglist . ,cont))
     (declare (dynamic-extent #',name)
              (inline ,name))
     . ,body))
(deftype mem () '(simple-array t 1))
(deftype list-of (element-type) (declare (ignore element-type)) t)
(deftype tree-of (element-type) (declare (ignore element-type)) t)
(defmacro defopt (name lambda-list &body body)
  (multiple-value-bind (forms decl doc) (sb-int:parse-body body t)
    (subst-if t (constantly nil) lambda-list :key
              (lambda (form)
                (when (and form (symbolp form))
                  (a:when-let (type (or (get form 'default-type)
                                        (and (defined-type-name-p form) form)))
                    (push `(declare (type ,type ,form)) decl)))
                (when (and form (symbolp form)
                           (defined-type-name-p form))
                  (push `(declare (type ,form ,form)) decl))))
    `(defun ,name ,lambda-list
       ,@(and doc (list doc))
       #+nil (declare (optimize (speed 3) (safety 0)))
       ,@decl ,@forms)))
;;; Language
(defstruct application (function) (args))
(defvar *types*)
(defvar *par*)
(defvar *contexts*)
(defvar *code-vars* nil)
(defun cartesian-cons (l ll)
  (loop for x in l nconc (mapcar (a:curry #'cons x) ll)))
(defun cartesian-products (ll)
  (reduce #'cartesian-cons ll :initial-value '(()) :from-end t))
(defun vars-of-type (type &optional no-recurse &aux vars)
  (loop for var in *code-vars*
        do (labels ((process (t1 expr)
                      (when (equal t1 type) (push expr vars))
                      (t:match t1
                        ((list 'cons car cdr)
                         (process car (list 'car expr))
                         (process cdr (list 'cdr expr)))
                        ((list 'function args result)
                         (unless no-recurse
                           (loop for args-terms in (cartesian-products (mapcar (a:rcurry #'vars-of-type t) args))
                                 do (process result (list* 'funcall expr args-terms))))))))
             (process (get var 'type) var)))
  (setq vars (nreverse vars))
  vars)
(defvar *library-functions* nil)
(defun library-arg-types-for (type)
  (cadr (find-if (lambda (l) (equal (caddr l) type))
                 *library-functions*)))
(defun library-functions-for (type)
  (let ((rows (remove-if-not (lambda (l) (equal (caddr l) type)) *library-functions*)))
    (values (mapcar #'car rows) (cadr (car rows)))))
(defun hole-1 (default type &aux context)
  (t:match type
    ((list 'cons a-type b-type)
     (t:ematch default
       ((list 'cons a-term b-term) `(cons ,(hole-1 a-term a-type) ,(hole-1 b-term b-type)))))
    (_
     (labels ((var (type &aux (vars (vars-of-type type)))
                (setf (getf context type) (length vars))
                `(etypecase spine
                   (fixnum
                    (if (< spine 0)
                        ,(default-1 type)
                        (case (the fixnum spine)
                          ,@(loop for var in vars
                                  for i from 0
                                  collect `((,i) ,var))
                          (t ,(default-1 type)))))))
              (application-clause (type)
                (a:when-let (arg-types (library-arg-types-for type))
                  `((application
                     (funcall (application-function spine)
                              ,@ (iter (for i from 0)
                                   (for arg-type in arg-types)
                                   (collect
                                       `(let ((spine (nth ,i (application-args spine))))
                                          ,(if (equal arg-type type)
                                               `(process spine)
                                               (process arg-type))))))))))
              (process (type)
                (t:ematch type
                  ((list 'list-of element-type)
                   `(labels ((process (spine)
                               (declare (ftype (function (t) list) process))
                               (etypecase spine
                                 (cons (cons (let ((spine (car spine)))
                                               ,(process element-type))
                                             (process (cdr spine))))
                                 (null nil)
                                 (fixnum ,(var type))
                                 ,@ (application-clause type))))
                      (process spine)))
                  ((list 'tree-of element-type)
                   `(labels ((process (spine)
                               (declare (ftype (function (t) list) process))
                               (etypecase spine
                                 (cons (list* (let ((spine (car spine)))
                                                ,(process element-type))
                                              (process (cadr spine))
                                              (process (cddr spine))))
                                 (null nil)
                                 (fixnum ,(var type))
                                 ,@ (application-clause type))))
                      (process spine)))
                  ('boolean
                   `(the boolean (etypecase spine
                                   (boolean spine)
                                   (fixnum ,(var type))
                                   ,@ (application-clause type))))
                  ('fixnum
                   (if (library-arg-types-for type)
                       `(labels ((process (spine)
                                   (etypecase spine
                                     (cons (let ((result
                                                   (the fixnum
                                                        (+ (the fixnum (let ((spine (car spine))) ,(var type)))
                                                           (the fixnum (cdr spine))))))
                                             #+nil (if (< result 0) 0 result) ;; Turn on when experiementing negative offset
                                             result))
                                     ,@ (application-clause type))))
                          (process spine))
                       `(etypecase spine
                          (cons (let ((result
                                        (the fixnum
                                             (+ (the fixnum (let ((spine (car spine))) ,(var type)))
                                                (the fixnum (cdr spine))))))
                                  #+nil (if (< result 0) 0 result) ;; Turn on when experiementing negative offset
                                  result)))))))
              (default (type default &aux (vars (vars-of-type type)))
                (flet ((varnum (var)
                         (let ((result (position var vars :test 'equal)))
                           (assert result) result)))
                  (t:ematch type
                    ((list 'list-of element-type)
                     (t:match default
                       ((list 'cons car cdr)
                        (cons (default element-type car) (default type cdr)))
                       ((list 'quote x)
                        (mapcar (lambda (y) (default element-type y)) x))
                       (nil -1)
                       (var (varnum var))))
                    ((list 'tree-of element-type)
                     (t:match default
                       ((list 'list* value left right)
                        (list* (default element-type value)
                               (default type left) (default type right)))
                       (nil -1) (var (varnum var))))
                    ('boolean
                     (t:match default
                       ((and c (type boolean)) c)
                       (var (varnum var))))
                    ('fixnum
                     (t:match default
                       ((list '+ (and c (type fixnum)) var)
                        (cons (position var vars :test 'equal) c))
                       ((and c (type fixnum)) (cons -1 c))
                       (var (cons (varnum var) 0))))))))
       (prog1 `(let ((spine (svref par ,(length *types*)))) ,(process type))
         (vector-push-extend type *types*)
         (vector-push-extend context *contexts*)
         (vector-push-extend (default type default) *par*))))))
(defmacro check-control-stack ()
  `(unless (> (sb-sys:%primitive sb-c:current-stack-pointer) stack-limit)
     (error 'o:state-not-promising)))
(defmacro recurse-1 (type i &rest clauses)
  (t:ematch type
    ((list 'list-of _)
     (destructuring-bind (tnil tcons) clauses
       `(labels ((process (i)
                   (check-control-stack)
                   (if (not i)
                       (funcall ,tnil)
                       (funcall ,tcons
                                (car i) (cdr i) (process (cdr i))))))
          (process ,i))))
    ((list 'tree-of _)
     (destructuring-bind (tnil tcons) clauses
       `(labels ((process (i)
                   (check-control-stack)
                   (if (not i)
                       (funcall ,tnil)
                       (funcall ,tcons (car i) (cadr i) (process (cadr i))
                                (cddr i) (process (cddr i))))))
          (process ,i))))
    ('boolean
     (destructuring-bind (ttrue tfalse) clauses
       `(if ,i
            (funcall ,ttrue)
            (funcall ,tfalse))))
    ('fixnum
     (destructuring-bind (tzero tsucc) clauses
       `(let ((limit ,i)
              (vstate (funcall ,tzero)))
          (loop for i-1 fixnum below limit
                do (setq vstate (funcall ,tsucc i-1 vstate)))
          vstate)))))
(defun genvar (name type &optional (code-var t))
  (let ((var (gensym (remove-if-not (lambda (c) (or (alpha-char-p c) (eq c #\-)))
                                    (symbol-name name)))))
    (setf (get var 'type) type)
    (setf (get var 'code-var) code-var)
    var))
(defun pfun-0 (args body)
  (bind ((vars (mapcar #'car args))
         (types (mapcar #'cadr args))
         (vars-1 (mapcar (a:curry #'apply #'genvar) args))
         (*code-vars* (append (remove-if-not (a:rcurry #'get 'code-var) vars-1) *code-vars*))
         ((:values term return-type) (convert (sublis (mapcar #'cons vars vars-1) body))))
    (values `(lambda ,vars-1 (declare (ignorable ,@vars-1))
               #+nil (declare . ,(mapcar (lambda (var-1 type) `(type ,type ,var-1)) vars-1 types))
               ,term)
            `(function ,types ,return-type))))
(defun return-type (type)
  (t:ematch type ((list 'function _ s-type) s-type)))
(defun convert (term)
  (t:match term
    ((list 'lambda args body) (pfun-0 args body))
    ((list 'let bindings body)
     (bind ((terms-alist (mapcar (a:multiple-value-compose #'cons #'convert #'cadr) bindings))
            ((:values term type)
             (pfun-0 (iter (for b in bindings) (for a in terms-alist)
                       (collect (list (car b) (cdr a))))
                     body)))
       (values `(funcall ,term ,@(mapcar #'car terms-alist))
               (return-type type))))
    ((list 'hole default type) (values (hole-1 default type) type))
    ((list 'hole type) (values (hole-1 (s:reify (default-1 type)) type) type))
    ((list* 'recurse i clause more-clauses)
     (bind (((:values i-term i-type) (convert i))
            ((:values c-term c-type) (convert clause)))
       (values `(recurse-1 ,i-type ,i-term ,c-term ,@(mapcar #'convert more-clauses))
               (return-type c-type))))
    ((list* 'funcall f args)
     (bind (((:values f-term f-type) (convert f)))
       (values `(progn (check-control-stack) (funcall ,f-term ,@(mapcar #'convert args)))
               (return-type f-type))))
    ((list 'cons a b)
     (bind (((:values a-term a-type) (convert a))
            ((:values b-term b-type) (convert b)))
       (values `(cons ,a-term ,b-term)
               `(cons ,a-type ,b-type))))
    ((type symbol) (values term (get term 'type)))
    ((list 'the type a) (values (convert a) type))
    (_ (if (constantp term)
           (values term (type-of term))
           (error "Illegal term ~s." term)))))
(defmacro with-pfun-context (() &body body)
  `(let ((*types* (make-array 16 :fill-pointer 0 :adjustable t))
         (*contexts* (make-array 16 :fill-pointer 0 :adjustable t))
         (*par* (make-array 16 :fill-pointer 0 :adjustable t)))
     . ,body))
(defun ensure-simple-array (array &optional (element-type t))
  (if (typep array `(simple-array ,element-type))
      array
      (map-into (make-array (length array) :element-type element-type)
                #'identity array)))
(defstruct (pfun (:constructor make-pfun (function printer types-1 contexts-1 return-type source)))
  (function (error "Unprovided.") :type function)
  (printer (error "Unprovided.") :type function)
  (types (ensure-simple-array types-1) :type mem)
  (contexts (ensure-simple-array contexts-1) :type mem)
  (return-type)
  (source)
  (library-functions *library-functions*))
(defmethod print-object ((object pfun) stream)
  (format stream "#.~a" (pfun-source object)))
(defun simplify-recurse (term)
  (labels ((occurs (x term)
             (if (consp term)
                 (or (occurs x (car term)) (occurs x (cdr term)))
                 (eq x term))))
    (t:match term
      ((list 'recurse 'boolean i
             (list 'lambda nil then) (list 'lambda nil else))
       (cond ((eq i t) then) ((eq i nil) else)
             (t term)))
      ((list 'recurse (list 'list-of _) i
             (list 'lambda nil tnil) (list 'lambda (list y tail s) tcons))
       (cond ((not i) tnil)
             ((eq s tcons) tnil)
             ((and (typep i '(cons (eql cons)))
                   (not (occurs y tcons))
                   (not (occurs tail tcons))
                   (not (occurs s tcons)))
              tcons)
             (t term)))
      ((list 'recurse 'fixnum i
             (list 'lambda nil tzero) (list 'lambda (list y s) tsucc))
       (cond ((eq i 0) tzero)
             ((eq s tsucc) tzero)
             ((and (typep i '(cons (eql +)))
                   (not (occurs y tsucc))
                   (not (occurs s tsucc)))
              tsucc)
             (t term)))
      (_ term))))
(defmacro pfun ((&rest args) &body body)
  (with-pfun-context ()
    `(values
      ,(bind ((expr (car body) #+nil (macroexpand-all (car body) env))
              ((:values code type) (pfun-0 args expr))
              (*compile-to-memory-space* :dynamic))
         (destructuring-bind (args-1 &body body) (cdr code)
           (handler-bind ((compiler-note #'muffle-warning)
                          (style-warning #'muffle-warning))
             (make-pfun (compile nil `(lambda (par . ,args-1)
                                        (declare (optimize (speed 3) #+nil (safety 0))
                                                 (type mem par))
                                        (let ((stack-limit
                                                (- (sb-sys:%primitive sb-c:current-stack-pointer)
                                                   16384)))
                                          ,@body)))
                        (let ((*inline-expansion-limit* 200)) ;; hack
                          (eval `(macrolet ((recurse-1 (type &rest args-2)
                                              `(s:reflect (simplify-recurse `(recurse ,',type ,@,`(list ,@(mapcar (a:curry #'list 's:reify) args-2))))))
                                            (ignore-2 (type x) (declare (ignore type)) x))
                                   (flet ((funcall-2 (f &rest args-2)
                                            (if (functionp (s:base f)) (apply f args-2)
                                                (apply #'s:partial-funcall 'funcall f args-2))))
                                     (lambda (par)
                                       (declare (optimize (debug 3)))
                                       (let ((*gensym-counter* 0)
                                             (stack-limit
                                               (- (sb-sys:%primitive sb-c:current-stack-pointer)
                                                  16384)))
                                         (s:reify ,(sublis '((the . ignore-2)
                                                             (car . scaena-cl:car)
                                                             (cdr . scaena-cl:cdr)
                                                             (funcall . funcall-2)
                                                             (+ . scaena-cl:+))
                                                           `(lambda ,args-1 ,@body)))))))))
                        *types* *contexts* (return-type type) `(pfun ,args ,expr)))))
      ,*par*)))

(defun print-pfun (pfun par)
  (let ((*print-circle* nil)
        (*print-gensym* nil))
    (print (funcall (pfun-printer pfun) par))
    (values)))
(defun call-pfun (pfun par &rest args)
  (apply (pfun-function pfun) par args))

;;; Operators
(eval-when (:compile-toplevel :load-toplevel :execute)
  (setf (get 'par 'default-type) 'mem)
  (setf (get 'args 'default-type) 'mem)
  (setf (get 'cont 'default-type) 'function))
(defun arities (type state-type)
  (t:ematch type
    ((list 'list-of a) `(() ((y ,a) (tail ,type) (s ,state-type))))
    ((list 'tree-of a) `(() ((y ,a) (tail ,type) (s ,state-type) (tail-1 ,type) (s-1 ,state-type))))
    ('boolean '(() ()))
    ('fixnum `(() ((y ,type) (s ,state-type))))))
(progn
  (declaim (inline initial-1 generate-mutations-1))
  (defun initial-1 (type)
    (t:ematch type
      ((list 'list-of _) -1)
      ((list 'tree-of _) -1)
      ('boolean -1)
      ('fixnum (cons -1 0))))
  (defun default-1 (type)
    (t:ematch type
      ((list 'list-of _) nil)
      ((list 'tree-of _) nil)
      ('boolean nil)
      ('fixnum 0)
      ((list 'cons a b) (cons (default-1 a) (default-1 b)))))
  (defun generate-mutations-1 (type context spine cont)
    (labels ((var (type spine cont)
               (let ((range (getf context type 0))
                     (spine (if (typep spine 'fixnum) spine
                                (progn (funcall cont 0) 0))))
                 (when (< (1+ spine) range)
                   (funcall cont (1+ spine)))
                 (when (>= spine 0)
                   (funcall cont (1- spine)))))
             (process (type spine cont)
               (multiple-value-bind (fs arg-types)  (library-functions-for type)
                 (if (application-p spine)
                     (progn
                       (klet ((cont (spine-1)
                                    (funcall cont (make-application :function (application-function spine)
                                                                    :args (cons spine-1 (cdr (application-args spine)))))))
                             (process (car arg-types) (car (application-args spine)) #'cont))
                       (when (equal (car arg-types) type)
                         (funcall cont (car (application-args spine))))
                       (when (cdr arg-types)
                         (klet ((cont (spine-1)
                                      (funcall cont (make-application :function (application-function spine)
                                                                      :args (list (car (application-args spine)) spine-1)))))
                               (process (cadr arg-types) (cadr (application-args spine)) #'cont))
                         (when (equal (cadr arg-types) type)
                           (funcall cont (cadr (application-args spine))))))
                     (progn
                       (let ((args (mapcar (lambda (arg-type)
                                             (if (equal arg-type type)
                                                 spine (initial-1 arg-type)))
                                           arg-types)))
                         (dolist (f fs)
                           (funcall cont (make-application :function f :args args))))
                       (t:ematch type
                         ((list 'list-of element-type)
                          (if (consp spine)
                              (progn
                                (funcall cont (cdr spine))
                                (klet ((cont (spine-1)
                                             (funcall cont (cons spine-1 (cdr spine)))))
                                      (process element-type (car spine) #'cont))
                                (klet ((cont (spine-1)
                                             (funcall cont (cons (car spine) spine-1))))
                                      (process type (cdr spine) #'cont)))
                              (var type spine cont))
                          (funcall cont (cons (initial-1 element-type) spine)))
                         ((list 'tree-of element-type)
                          (if (consp spine)
                              (progn
                                (funcall cont (cadr spine))
                                (funcall cont (cddr spine))
                                (klet ((cont (spine-1)
                                             (funcall cont (cons spine-1 (cdr spine)))))
                                      (process element-type (car spine) #'cont))
                                (klet ((cont (spine-1)
                                             (funcall cont (list* (car spine) spine-1 (cddr spine)))))
                                      (process type (cadr spine) #'cont))
                                (klet ((cont (spine-1)
                                             (funcall cont (list* (car spine) (cadr spine) spine-1))))
                                      (process type (cddr spine) #'cont)))
                              (var type spine cont))
                          #+nil (funcall cont (list* (initial-1 element-type) spine (initial-1 type)))
                          #+nil (funcall cont (list* (initial-1 element-type) (initial-1 type) spine))
                          (funcall cont (list* (initial-1 element-type) spine spine)))
                         ('boolean
                          (var type spine cont)
                          (funcall cont t))
                         ('fixnum
                          (klet ((cont (varnum)
                                       (funcall cont (cons varnum (cdr spine)))))
                                (var type (car spine) #'cont))
                          (funcall cont (cons (car spine) (1+ (cdr spine))))
                          (when (> (cdr spine) 0)
                            (funcall cont (cons (car spine) (1- (cdr spine))))))))))))
      (process type spine cont)))
  (defun initial (pfun)
    (map 'vector #'initial-1 (pfun-types pfun)))
  (defopt generate-mutations (pfun par cont)
    (with-slots (types contexts) pfun
      (loop for spine across par
            for type across types
            for context across contexts
            for i fixnum from 0
            do (klet ((cont (spine)
                            (let ((par (copy-seq par)))
                              (setf (aref par i) spine)
                              (funcall cont par))))
                     (generate-mutations-1 type context spine #'cont))))))
(defun levenshtein-distance (element-type seq1 seq2)
  (declare (list seq1 seq2))
  (let* ((seq1 (map 'simple-vector #'identity seq1))
         (seq2 (map 'simple-vector #'identity seq2))
         (n (length seq1))
         (m (length seq2))
         (column-height (1+ m)))
    (declare ((simple-array *) seq1 seq2))
    (flet ((norm (x) (1+ (cost-error-1 element-type x (default-1 element-type)))))
      (cond ((= 0 n) (return-from levenshtein-distance (reduce #'+ seq2 :key #'norm)))
            ((= 0 m) (return-from levenshtein-distance (reduce #'+ seq1 :key #'norm))))
      (let ((error-col (make-array column-height :element-type '(integer 0 100000)))
            (error-col-previous (make-array column-height :element-type '(integer 0 100000))))
        (declare ((simple-array (integer 0 100000)) error-col error-col-previous))
        ;; We need to store only two columns---the current one that is being built and the previous one
        ;; Fill the the first column:
        (setf (aref error-col-previous 0) 0)
        (loop for j below m
              sum (norm (aref seq2 j)) into sum
              do (setf (aref error-col-previous (1+ j)) sum))
        ;; Loop across all chars of each string
        (loop for i below n
              sum (norm (aref seq1 i)) into sum
              do (setf (aref error-col 0) sum)
              do (dotimes (j m)
                   (let* ((j-plus-one (1+ j))
                          (a (+ (aref error-col j)
                                (norm (aref seq2 j))))  ;; ins?
                          (b (+ (aref error-col-previous j-plus-one)
                                (norm (aref seq1 i)))) ;; del?
                          (match-value (cost-error-1 element-type (aref seq1 i) (aref seq2 j)))
                          (c (+ (aref error-col-previous j) match-value))
                          (min (min a b c)))
                     ;; Save the minimum
                     (setf (aref error-col j-plus-one) min)))
              do (rotatef error-col error-col-previous))
        (aref error-col-previous m)))))

(defun tree-edit-distance (type tree-1 tree-2)
  (let ((memo (make-hash-table :test 'equal))
        (element-type (cadr type)))
    (labels ((process (tree-1 tree-2)
               (or (gethash (cons tree-1 tree-2) memo)
                   (setf (gethash (cons tree-1 tree-2) memo)
                         (cond ((not tree-1) (size tree-2 type))
                               ((not tree-2) (size tree-1 type))
                               (t (min (1+ (process (cadr tree-1) tree-2))
                                       (1+ (process (cddr tree-1) tree-2))
                                       (1+ (process tree-1 (cadr tree-2)))
                                       (1+ (process tree-1 (cddr tree-2)))
                                       (+ (cost-error-1 element-type (car tree-1) (car tree-2))
                                          (process (cadr tree-1) (cadr tree-2))
                                          (process (cddr tree-1) (cddr tree-2))))))))))
      (process tree-1 tree-2))))

(locally
    (declare (optimize (speed 3) #+nil (debug 3) (safety 0) (space 0)))
  (declaim (inline fastlog2 cost-error cost-norm in-degree)
           (ftype (function (t t) fixnum) cost-norm-1))
  (defun fastlog2 (p)
    "Compute log2(P) approximately for *positive* integer P."
    (declare (type fixnum p))
    (let* ((exponent (1- (integer-length p)))
           (x (scale-float (coerce p 'single-float) (- exponent))))
      (declare (type single-float x))
      (+ exponent (- (* -0.4326728 x (- x 5.261706)) 1.8439242))))
  (declaim (ftype (function (t t t) fixnum) cost-error-1))
  (defopt cost-error-1 (type value value-1)
    (t:ematch type
      ((list 'list-of element-type)
       (or (ignore-errors (levenshtein-distance element-type value value-1))
           1000.0))
      ((list 'tree-of _) (tree-edit-distance type value value-1))
      ((list 'cons a b)
       (+ (cost-error-1 a (car value) (car value-1))
          (cost-error-1 b (cdr value) (cdr value-1))))
      ('boolean (if (eq value value-1) 0 1))
      ('fixnum (abs (the fixnum (- (the fixnum value) (the fixnum value-1)))))))
  (defopt cost-error (pfun par seq)
    (loop for (input output) in seq
          sum (let ((output-1 (apply (pfun-function pfun) par input)))
                (fastlog2 (the fixnum (1+ (cost-error-1 (pfun-return-type pfun) output output-1)))))
          single-float))
  (defopt cost-norm-1 (type spine)
    (labels ((process (type spine)
               (the fixnum
                    (if (application-p spine)
                        (iter (for arg-type in (library-arg-types-for type))
                          (for arg in (application-args spine))
                          (summing (the fixnum (process arg-type arg)) into (the fixnum sum))
                          (finally (return (the fixnum (+ 2 sum)))))
                        (t:ematch type
                          ((list 'list-of element-type)
                           (etypecase spine
                             (cons (+ 1 (process element-type (car spine))
                                      (process type (cdr spine))))
                             (fixnum 0)))
                          ((list 'tree-of element-type)
                           (etypecase spine
                             (cons (+ 1 (process element-type (car spine))
                                      (process type (cadr spine))
                                      (process type (cddr spine))))
                             ((or null fixnum) 0)))
                          ('boolean 0)
                          ('fixnum (abs (the fixnum (cdr spine)))))))))
      (process type spine)))
  (defopt cost-norm (pfun par)
    (loop for spine across par
          for type across (pfun-types pfun)
          sum (fastlog2 (the fixnum (1+ (the fixnum (cost-norm-1 type spine))))) single-float))
  (defopt cost (pfun par seq)
    (let ((cost-1 (the single-float (cost-error pfun par seq))))
      (values (+ cost-1 (the single-float (cost-norm pfun par))) cost-1))))

;;;; Search Algorithms
(defclass prf-problem (o:problem)
  ((pfun :initarg :pfun)
   (seq :initarg :seq)
   (timeout :initarg :timeout)))
(defvar *pc* 0)
(o:defmethod-1 o:cost () (prf-problem parameter)
  (incf *pc*)
  (handler-case
      (multiple-value-bind (cost cost-1)
          (cost pfun parameter seq)
        (when (= cost-1 0.0)
          (let ((result (list (pfun-source pfun) parameter #+nil (reverse o::trace))))
            (format *trace-output* "~&Found ~a with cost ~a(~a).~%" result cost cost-1)
            (throw 'search result)))
        cost)
    (o:state-not-promising () 1000.0)))
(o:defmethod-1 o:mutate () (prf-problem parameter cont)
  (let ((*library-functions* (pfun-library-functions pfun)))
    (generate-mutations pfun parameter cont)))
(defclass prf-mh (prf-problem o:metro-hastings) ())
(defclass prf-bfs (prf-problem bfs) ())
(defun stop-tasks ()
  (sleep 0.1) ;; avoid some race conditions
  (iter (for worker in-vector (lparallel.kernel::workers lparallel:*kernel*))
    (for thread = (lparallel.kernel::thread worker))
    (interrupt-thread thread (lambda () (ignore-errors (throw 'search nil))))))
(defun random-search (pfuns seq
                      &key (beta 5.0) (restart 50000) (timeout 1.0)
                      &allow-other-keys)
  (setq *pc* 0)
  (let ((channel (lparallel:make-channel)))
    (unwind-protect
         (progn
           (iter (for _ below (lparallel:kernel-worker-count))
             (lparallel:submit-task
              channel
              (lambda ()
                (bind ((optimizers
                        (a:rotate
                         (iter (for pfun in pfuns)
                           (collect (make-instance 'prf-mh :pfun pfun :seq seq :parameter (copy-seq (initial pfun)) :beta-m beta :timeout timeout)))
                         (floor (* (length pfuns) (lparallel:kernel-worker-index))
                                (lparallel:kernel-worker-count)))))
                  (catch 'search
                    (iter (for i from 0)
                      (iter (for optimizer in optimizers)
                        (bind (((:slots timeout) optimizer))
                          (call-with-timing
                           (lambda (&key real-time-ms &allow-other-keys)
                             (setq timeout
                                   (/ (+ (* i timeout) (/ real-time-ms 1000.0)) (1+ i))))
                           (lambda ()
                             (handler-case
                                 (sb-ext:with-timeout (* timeout 1.5)
                                   (iter (for i below restart)
                                     (o:run optimizer)))
                               ((or error timeout) ()))))
                          (reinitialize-instance optimizer :parameter (copy-seq (initial (slot-value optimizer 'pfun))))))))))))
           (lparallel:receive-result channel))
      (stop-tasks))))
(defun serial-search (pfuns seq
                      &key (beta 5.0) (restart 50000) (timeout 1.0) (total-timeout 60.0)
                      &allow-other-keys)
  (setq *pc* 0)
  (bind ((optimizers
          (iter (for pfun in pfuns)
            (collect (make-instance 'prf-mh :pfun pfun :seq seq :parameter (copy-seq (initial pfun)) :beta-m beta :timeout timeout))))
         (deadline (floor (+ (get-internal-real-time) (* total-timeout internal-time-units-per-second)))))
    (catch 'search
      (iter (for i from 0)
        (while (< (get-internal-real-time) deadline))
        (iter (for optimizer in optimizers)
          (bind (((:slots timeout) optimizer))
            (call-with-timing
             (lambda (&key real-time-ms &allow-other-keys)
               (setq timeout
                     (/ (+ (* i timeout) (/ real-time-ms 1000.0)) (1+ i))))
             (lambda ()
               (handler-case
                   (sb-ext:with-timeout (* timeout 1.5)
                     (iter (for i below restart)
                       (o:run optimizer)))
                 ((or error timeout) ()))))
            (reinitialize-instance optimizer :parameter (copy-seq (initial (slot-value optimizer 'pfun))))))))))
(defun bfs (pfuns seq &key (restart 50000) &allow-other-keys)
  (let ((channel (lparallel:make-channel)))
    (unwind-protect
         (progn
           (iter (for _ below (lparallel:kernel-worker-count))
             (lparallel:submit-task
              channel
              (lambda ()
                (bind ((optimizers
                        (iter (for pfun in (nthcdr (lparallel:kernel-worker-index) pfuns)
                                   by (a:curry #'nthcdr (lparallel:kernel-worker-count)))
                          (collect (make-instance 'prf-bfs :pfun pfun :seq seq :parameter (copy-seq (initial pfun)))))))
                  (catch 'search
                    (loop
                      (iter (for optimizer in optimizers)
                        (handler-case
                            (iter (for i below restart)
                              (o:run optimizer))
                          (error (c) (describe c))))))))))
           (lparallel:receive-result channel))
      (stop-tasks))))
(defun gc-safeguard ()
  (unless (< (sb-kernel:dynamic-usage) (* 16000 1000000))
    (stop-tasks)))
(pushnew 'gc-safeguard sb-ext:*after-gc-hooks*)
;;;; Utils
(defun properly-nested-term (state-type recursion-types)
  (trivia:match state-type
    ((list 'function (list arg-type) result-type)
     `(funcall
       ,(trivia:match recursion-types
          ((cons type rest)
           `(recurse (hole ,type)
                     (lambda ,(nth 0 (arities type state-type))
                       (lambda ((x ,arg-type))
                         ,(if (eq type 'boolean)
                              (properly-nested-term state-type rest)
                              `(hole ,result-type))))
                     (lambda ,(nth 1 (arities type state-type))
                       (lambda ((x ,arg-type))
                         ,(properly-nested-term state-type rest)))))
          (nil `(lambda ((x ,arg-type)) (hole ,result-type))))
       (hole ,arg-type)))
    #+nil ((list 'cons type-1 type-2)
           (trivia:match recursion-types
             ((cons type rest)
              `(recurse (hole ,type)
                        (lambda ,(nth 0 (arities type state-type))
                          ,(if (eq type 'boolean)
                               (properly-nested-term state-type rest)
                               `(hole ,state-type)))
                        (lambda ,(nth 1 (arities type state-type))
                          (cons ,(properly-nested-term type-1 rest)
                                ,(properly-nested-term type-2 rest)))))
             (nil `(hole ,state-type))))
    ((list 'cons _ _)
     (trivia:match recursion-types
       ((cons type rest)
        `(recurse (hole ,type)
                  (lambda ,(nth 0 (arities type state-type))
                    ,(if (eq type 'boolean)
                         (properly-nested-term state-type rest)
                         `(hole ,state-type)))
                  (lambda ,(nth 1 (arities type state-type))
                    ,(properly-nested-term state-type rest))))
       (nil `(hole ,state-type))))
    (_
     (trivia:match recursion-types
       ((cons type rest)
        `(recurse (hole ,(s:reify (default-1 type)) ,type)
                  (lambda ,(nth 0 (arities type state-type))
                    ,(if (eq type 'boolean)
                         (properly-nested-term state-type rest)
                         `(hole ,state-type)))
                  (lambda ,(nth 1 (arities type state-type)) ,(properly-nested-term state-type rest))))
       (nil `(hole ,state-type))))))
(define-memo-function (properly-nested :table (make-hash-table :test 'equal :synchronized t)) (&rest args)
  (destructuring-bind (argument-types result-type state-type recursion-types &rest library-functions) args
    (let* ((*library-functions* library-functions)
           (pfun (eval `(pfun ,(cl:mapcar (lambda (type) (list (gensym) type)) argument-types)
                              (let ((result ,(properly-nested-term state-type recursion-types)))
                                (hole ,(s:reify (default-1 result-type)) ,result-type))))))
      (setf (pfun-source pfun) (cons 'properly-nested (mapcar (a:curry #'list 'quote) args)))
      pfun)))
(defvar *problems* nil)
(defmacro defproblem (name argument-types result-type args &body body)
  `(progn
     (export '(,name))
     (pushnew ',name *problems*)
     (setf (get ',name :argument-types) ',argument-types)
     (setf (get ',name :result-type) ',result-type)
     (setf (get ',name :reference) (labels ((recurse ,args ,@body)) #'recurse))))

(defun collect-types (types)
  (delete-duplicates
   (mapcan (lambda (type)
             (t:ematch type
               ((list 'function argument-types result-type)
                (collect-types (cons result-type argument-types)))
               ((list (or 'tree-of 'list-of) element-type)
                (cons type (collect-types (list element-type))))
               ((list 'cons a b) (collect-types (list a b)))
               (_ (list type))))
           types)
   :test 'equal))
(defun problem-pfuns (symbol depth library-functions)
  (bind (((:plist argument-types result-type) (symbol-plist symbol))
         (types (collect-types (list* (list 'function argument-types result-type)
                                      (mapcar (lambda (item) (cons 'function (cdr item))) library-functions))))
         (state-types (append types
                              (mapcon (lambda (types)
                                        (nconc (mapcar (lambda (type-1) `(cons ,(car types) ,type-1)) types)
                                               (mapcar (lambda (type-1) `(function (,(car types)) ,type-1)) types)))
                                      types)))
         (recursion-types
          (remove-if (lambda (types)
                       (> (reduce #'+ types :key (lambda (type) (1+ (length (nth 1 (arities type state-types)))))) 18))
                     (iter (with recursion-types = (list nil))
                       (for i below depth)
                       (setq recursion-types
                             (delete-duplicates (mapcan (lambda (types-1)
                                                          (mapcar (lambda (type-1) (cons type-1 types-1))
                                                                  types))
                                                        recursion-types)
                                                :test 'equal))
                       (finally (return recursion-types))))))
    (format *trace-output* "Compiling ~a skeletons for ~a...~%"
            (* (length state-types) (length recursion-types)) symbol)
    (lparallel:pmapcan
     (lambda (rt)
       (lparallel:pmapcar
        (lambda (st)
          (apply #'properly-nested argument-types result-type st rt library-functions))
        state-types))
     recursion-types)))
(defun solve-problem (symbol examples &rest options
                      &key (depth 3) library silent (method 'random-search)
                        (total-timeout 60.0) &allow-other-keys)
  (bind (((:plist library-functions) (symbol-plist symbol))
         (library-functions (when library
                              (unless library-functions (return-from solve-problem))
                              library-functions))
         (pfuns (problem-pfuns symbol depth library-functions))
         time
         (result
          (call-with-timing
           (lambda (&key real-time-ms &allow-other-keys)
             (setq time (/ real-time-ms 1000.0)))
           (lambda ()
             (format *trace-output* "Search start for ~a.~%" symbol)
             (handler-case
                 (with-timeout total-timeout
                   (apply method pfuns examples options))
               (timeout ())))))
         (correct-p (when result (test-solution symbol (eval (car result)) (cadr result)))))
    (unless (eq method 'serial-search)
      (stop-tasks))
    (unless silent
      (push (list* options time correct-p examples result) (gethash symbol *results*)))))

;;; Experiments

(defvar *print-depth* 0)
(defun print-haskell (pfun par)
  (let ((lisp (funcall (pfun-printer pfun) par))
        (*print-case* :downcase))
    (labels ((process (term)
               (t:ematch term
                 ((list 'recurse (list 'list-of _) i
                        (list 'lambda nil tnil) (list 'lambda (list y tail s) tcons))
                  (let ((*print-depth* (+ 2 *print-depth*)))
                    (format nil "para alg ~a where
~v@Talg NilF = ~a
~v@Talg (ConsF ~a (~a, ~a)) = ~a" (process i) *print-depth* (process tnil) *print-depth* y tail s (process tcons))))
                 ((list 'recurse 'fixnum i
                        (list 'lambda nil tzero) (list 'lambda (list y s) tsucc))
                  (let ((*print-depth* (+ 2 *print-depth*)))
                    (format nil "para alg ~a where
~v@Talg ZeroF = ~a
~v@Talg (SuccF (~a, ~a)) = ~a" (process i) *print-depth* (process tzero) *print-depth* y s (process tsucc))))
                 ((list 'recurse 'boolean i
                        (list 'lambda nil then) (list 'lambda nil else))
                  (let ((*print-depth* (+ 2 *print-depth*)))
                    (format nil "if ~a
~v@Tthen ~a
~v@Telse ~a" (process i) *print-depth* (process then) *print-depth* (process else))))
                 ((list 'cons a b) (format nil "(~a, ~a)" (process a) (process b)))
                 ((list 'car a) (format nil "fst ~a" (process a)))
                 ((list 'cdr a) (format nil "snd ~a" (process a)))
                 ((list* 'funcall args) (format nil "~{~a~^ ~}" (mapcar #'process args)))
                 ((list 'lambda args body) (format nil "\\~{~a~^ ~}-> ~a" args (process body)))
                 (nil "[]")
                 (_ term))))
      (write-string (process lisp))
      (terpri))))

(defvar *results* (make-hash-table :synchronized t))
(defvar *tests*)
(defvar *examples*)

(defmacro choose (&rest clauses)
  `(ecase (random ,(length clauses))
     ,@(iter (for i from 0)
         (for c in clauses)
         (collect (list i c)))))
(defun sample (type)
  (t:ematch type
    ((list 'list-of element-type)
     (choose
      nil
      (cons (sample element-type) (sample type))))
    ((list 'tree-of element-type)
     (choose
      nil
      (list* (sample element-type) (sample type) (sample type))))
    ((list 'tree-1-of element-type)
     (choose
      (sample element-type)
      (list* (sample element-type) (sample type) (sample type))))
    ('fixnum (choose 0 (1+ (sample type))))
    ('boolean (choose t nil))
    ((list 'cons a b) (cons (sample a) (sample b)))
    ('(function (fixnum) boolean) (choose 'evenp 'prf-user:nzp))
    ('(function (fixnum) fixnum) (choose 'prf-user:inc 'prf-user:div2))
    ('(function (fixnum fixnum) fixnum) (choose '+ 'prf-user:count-odd))
    ((list* 'function _)
     (error "Todo"))
    ('null nil)))
(defun size (value type)
  (t:ematch type
    ((list 'list-of element-type)
     (if (consp value)
         (+ 1 (size (car value) element-type)
            (size (cdr value) type))
         0))
    ((list 'tree-of element-type)
     (if (consp value)
         (+ 1 (size (car value) element-type)
            (size (cadr value) type)
            (size (cddr value) type))
         0))
    ((list 'tree-1-of element-type)
     (if (consp value)
         (+ 1 (size (car value) element-type)
            (size (cadr value) type)
            (size (cddr value) type))
         (size value element-type)))
    ('fixnum value)
    ('boolean (if value 1 0))
    ((list 'cons a b) (+ (size (car value) a) (size (cdr value) b)))
    ((list* 'function _) 1)
    ('null 0)))
(defun samples (type n &optional (size 50))
  (let (results)
    (iter (while (< (length results) n))
      (let ((sample (sample type)))
        (when (< (size sample type) size)
          (pushnew sample results :test #'equal))))
    (sort results #'< :key (a:rcurry #'size type))))
(defun generate-examples (symbol n &optional (output-size (get symbol :output-size 200)))
  (bind (((:plist argument-types result-type reference) (symbol-plist symbol))
         (argument-type (reduce (a:curry #'list 'cons) argument-types :initial-value 'null :from-end t)))
    (let (results)
      (iter (for _ below 1000)
        (while (< (length results) n))
        (let ((inputs (sample argument-type)))
          (when (< (size inputs argument-type) 30)
            (let ((output (apply reference inputs)))
              (when (< (size output result-type) output-size)
                (pushnew (list inputs output) results :test #'equal))))))
      (sort results #'< :key (lambda (r) (size (car r) argument-type))))))

(defun find-result (symbol table library &optional (depth 3))
  (mapcar #'cdr (remove-if-not (lambda (r) (and (eq (getf (car r) :library) library)
                                                (eq (getf (car r) :depth 3) depth)))
                               (gethash symbol table))))

(defun test-solution (symbol pfun par)
  (bind ((tests (gethash symbol *tests*)))
    (handler-case
        (with-timeout 1
          (iter (for (inputs output) in tests)
            (accumulate
             (equal (apply #'call-pfun pfun par inputs)
                    output)
             by #'and initial-value t)))
      (t ()))))

(defun save-table (table filename)
  (with-open-file (stream filename :if-exists :supersede
                                   :direction :output)
    (write-string "(" stream)
    (iter (for (k vs) in-hashtable table)
      (bind (*print-pretty*)
        (write-string "(" stream)
        (prin1 k stream)
        (iter (for v in vs)
          (terpri stream)
          (prin1 v stream))
        (write-string ")" stream)
        (terpri stream)))
    (write-string ")" stream)
    (values)))
(defun load-table (filename)
  (if (uiop:file-exists-p filename)
      (a:alist-hash-table (uiop:read-file-form filename) :synchronized t)
      (make-hash-table :synchronized t)))
(defmacro with-temporary-file ((namestring string) &body body)
  `(uiop:with-temporary-file (:stream %stream :pathname %pathname)
     (write-string ,string %stream) :close-stream
     (let ((,namestring (uiop:unix-namestring %pathname)))
       ,@body)))
(defun pending-examples (problem table library &optional (depth 3))
  (set-difference
   (gethash problem *examples*)
   (mapcar (lambda (r) (nth 2 r)) (find-result problem table library depth))
   :test 'equal))

(defun analyze-results (results &optional prf (total-timeout 60))
  (let (times (timeouts 0) (wrongs 0) (fails 0) (mem 0))
    (iter (for result in results)
      (cond ((>= (car result) total-timeout)
             (if (or (equal (cadr result) "Timed out")
                     (equal (cadr result) "")
                     (not (cadr result)))
                 (incf timeouts)
                 (incf fails)))
            ((and (not (nth 3 result)) prf)
             (incf mem))
            ((not (nth 1 result))
             (incf wrongs))
            (t (push (car result) times))))
    (list (if times
              (a:mean times)
              (format nil "\\textcolor{red}{~A}"
                      (caar (sort (list (cons "time" timeouts)
                                        (cons "wrong" wrongs)
                                        (cons "fail" fails)
                                        (cons "mem" mem))
                                  #'> :key #'cdr))))
          (if times (length times) "-"))))

(defun prf-results (problem results library &optional (total-timeout 60))
  (let (depth n avg)
    (iter (for depth-1 below 4)
      (for (avg-1 n-1) = (analyze-results (find-result problem results library depth-1) t total-timeout))
      (when (or (not (numberp n))
                (ignore-errors (< n n-1)))
        (setq depth depth-1 avg avg-1 n n-1)))
    (list depth avg n)))
