(defpackage #:scaena
  (:use #:cl)
  (:local-nicknames (#:a #:alexandria) (#:f #:fset))
  (:shadow #:type-of)
  (:export #:gensym-like #:reify #:multiple-value-reify #:reflect #:*ignorable-lambda-vars*
           #:layers #:get-layer #:base #:plist
           #:define-layer-apply-hook #:hints #:get-hint
           #:syntax #:syntax-p #:syntax-term #:type-of #:non-literal
           #:residual-funcall #:partial-funcall-1 #:partial-funcall))

(defclass layers ()
  ((base :initarg :base :accessor base) (plist :initarg :plist :accessor plist))
  (:metaclass c2mop:funcallable-standard-class))
(defun compute-application-layers (layers function &rest args)
  (loop for layer in layers
        nconc (list layer (apply (get layer 'layer-apply-hook #'apply) (get-layer function layer) args))))
(defmethod initialize-instance :after ((obj layers) &key)
  (c2mop:set-funcallable-instance-function
   obj
   (lambda (&rest args)
     (let ((result (apply (base obj) args)))
       (apply #'layers result (apply #'compute-application-layers (collect-layers obj) obj args))))))
(defmethod print-object ((datum layers) stream)
  (format stream "#.(layers ~a ~{~a~^ ~})" (base datum) (plist datum)))
(defmacro define-layer-apply-hook (layer (op args) &body body)
  (let ((apply-hook-name (intern (format nil "~a-APPLY-HOOK" layer))))
    `(progn
       (defun ,apply-hook-name (,op &rest ,args) ,@body)
       (setf (get ',layer 'layer-apply-hook) #',apply-hook-name))))
(defun collect-layers (&rest args &aux layers)
  (dolist (arg args)
    (loop for (key _1 . _) on (plist arg) by #'cddr
          do (pushnew key layers)))
  layers)
(defun plist-union (l1 l2 &aux (result l2))
  (loop for (key value . _) on l1 by #'cddr
        when (eq (getf l2 key 'unbound) 'unbound)
          do (setq result (list* key value result)))
  result)
(defun layers (base &rest plist)
  (if plist
      (if (typep base 'layers)
          (make-instance 'layers :base (base base) :plist (plist-union (plist base) plist))
          (make-instance 'layers :base base :plist plist))
      base))
(defmethod base (datum) datum)
(defmethod plist (datum) nil)
(defgeneric get-layer (datum layer)
  (:method (datum layer) (getf (plist datum) layer)))
(defgeneric (setf get-layer) (new-val datum layer)
  (:method (new-val datum layer) (setf (getf (plist datum) layer) new-val)))

;;; Core
(defstruct (syntax (:predicate syntax-p-1)) (term))
(defun syntax-p (x) (syntax-p-1 (base x)))
(deftype non-literal () '(or cons (and symbol (not null) (not (eql t)) (not keyword))))
(defvar *hints* (make-hash-table :weakness :key :synchronized t))
(defvar *ignorable-lambda-vars* nil)
(defun hint! (term &rest plist)
  (sb-ext:with-locked-hash-table (*hints*)
    (setf (gethash term *hints*) (plist-union (gethash term *hints*) plist)))
  term)
(defmacro hints (term) `(gethash ,term *hints*))
(defmacro get-hint (term layer) `(getf (hints ,term) ,layer))
(defun reflect (term &rest plist)
  (apply #'layers
         (cond ((and (consp term) (eq (car term) 'quote))
                (cadr term))
               ((typep term 'non-literal) (make-syntax :term term))
               (t term))
         (plist-union (hints term) plist)))
(defun obscure-arglist-p (arglist)
  (or (eq arglist :unknown)
      (some (a:rcurry #'member '(&optional &rest &key)) arglist)))
(defun gensym-like (thing)
  (gensym (delete-if-not #'alpha-char-p (format nil "~A" thing))))
(defun reify (semantics &aux (base (base semantics)))
  (apply #'hint!
         (typecase base
           (syntax (syntax-term base))
           (function
            (let ((arglist (arg:arglist base)))
              (if (obscure-arglist-p arglist) base
                  (let* ((vars (mapcar #'gensym-like (arg:arglist base)))
                         (ftype (get-layer semantics 'type))
                         (argtypes (if (consp ftype) (cadr ftype) (mapcar (constantly t) vars))))
                    (assert (= (length vars) (length argtypes)))
                    `(lambda ,vars
                       ,@(when *ignorable-lambda-vars* `((declare (ignorable ,@vars))))
                       ,(reify (apply base (loop for var in vars for type in argtypes
                                                 collect (reflect var 'type type)))))))))
           (cons (list 'cons (reify (car base)) (reify (cdr base))))
           (non-literal (list 'quote base))
           (t base))
         (plist semantics)))
(defmacro multiple-value-reify (value-form)
  `(let* ((values-list (multiple-value-list ,value-form))
          (forms (mapcar #'reify values-list)))
     (values (if (cdr forms) (cons 'values forms) (car forms)) (length values-list))))

(defun normalize-values-type (type)
  (cond ((atom type) type)
        ((eq (car type) 'values) (cadr type))
        (t type)))
(define-layer-apply-hook type (ftype args)
  (if (or (functionp ftype)
          (and (symbolp ftype)
               (not (member ftype '(symbol function)))))
      (apply ftype args)
      (if (atom ftype) t (normalize-values-type (caddr ftype)))))
(defmethod get-layer (datum (layer (eql 'type)))
  (or (call-next-method)
      (get-hint datum 'type)
      (when (consp datum)
        (list 'cons (get-layer (car datum) 'type) (get-layer (cdr datum) 'type)))
      #+sbcl (ignore-errors (sb-introspect:function-type datum))
      (ignore-errors (a:assoc-value (nth-value 2 (trivial-cltl2:function-information datum)) 'ftype))
      (cl:type-of datum)))
(defun residual-funcall (source &rest args)
  (apply #'reflect (cons source (mapcar #'reify args))
         (apply #'compute-application-layers (apply #'collect-layers args) source args)))
(defun ac-funcall (source &rest args &aux static dynamic)
  (dolist (arg args) (if (syntax-p arg) (push (reify arg) dynamic) (push arg static)))
  (setq dynamic
        (loop for term in dynamic
              if (and (consp term) (eq (car term) source))
                append (cdr term)
              else collect term))
  (let ((terms (sort dynamic #'< :key #'sxhash)))
    (when static (push (apply source (mapcar #'base static)) terms))
    (apply #'reflect
           (cond ((cdr terms) (cons source terms))
                 (terms (car terms))
                 (t (funcall source)))
           (apply #'compute-application-layers (apply #'collect-layers args) source args))))
(defun partial-funcall (source &rest args)
  "Construct an application term that applies SOURCE to ARGS."
  (if (notany #'syntax-p args)
      (apply source (mapcar #'base args))
      (apply #'residual-funcall source args)))
(defun hack-macroexpand (form env &optional (package *package*))
  (let ((old (make-hash-table)))
    (labels ((walk (form)
               (typecase form
                 (cons (setf (gethash form old) form)
                  (mapc #'walk form) nil)
                 (t nil)))
             (process (form)
               (or (gethash form old)
                   (typecase form
                     (cons (mapcar #'process form))
                     (symbol (or (find-symbol (symbol-name form) package) form))
                     (t form)))))
      (walk form)
      (process (macroexpand form env)))))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (let* ((redefinitions '(car cdr cadr svref + * expt sqrt min max - / 1+ 1- abs mod floor = mapcar length < >
                          if assert not and or cond))
         (package (uiop:ensure-package "SCAENA-CL" :shadow redefinitions :export redefinitions :use '("CL"))))
    (trivial-package-local-nicknames:add-package-local-nickname "O" package)))
(defun o:car (x) (partial-funcall 'car x))
(defun o:cdr (x) (partial-funcall 'cdr x))
(defun o:cadr (x) (o:car (o:cdr x)))
(setf (get-hint 'car 'type)
      (lambda (x)
        (let ((type (get-layer x 'type)))
          (if (and (consp type) (eq (car type) 'cons))
              (cadr type) t))))
(setf (get-hint 'cdr 'type)
      (lambda (x)
        (let ((type (get-layer x 'type)))
          (if (and (consp type) (eq (car type) 'cons))
              (caddr type) t))))
(defun o:svref (simple-vector index) (partial-funcall 'svref simple-vector index))
;;; Arithmetic
(defun eql-1 (x y) (or (eql x y) (and (numberp x) (numberp y) (= x y))))
(defun o:+ (&rest args)
  (setq args (remove-if (a:curry 'eql-1 0) args))
  (apply #'ac-funcall '+ args))
(defun o:* (&rest args)
  (when (find 0 args :test #'eql-1) (return-from o:* 0))
  (setq args (remove-if (a:curry 'eql-1 1) args))
  (apply #'ac-funcall '* args))
(defun o:expt (base power)
  (cond ((eql power 0) 1)
        ((eql power 1) base)
        (t (partial-funcall 'expt base power))))
(defun o:sqrt (x) (partial-funcall 'sqrt x))
(defun o:min (&rest args) (apply #'ac-funcall 'min args))
(defun o:max (&rest args) (apply #'ac-funcall 'max args))
(defun o:- (number &rest more-numbers)
  (if more-numbers
      (o:+ number (o:- (apply #'o:+ more-numbers)))
      (if (and (syntax-p number) (typep (reify number) '(cons (eql -))))
          (reflect (cadr (reify number)))
          (partial-funcall '- number))))
(defun o:/ (number &rest more-numbers)
  (if more-numbers
      (o:* number (o:/ (apply #'o:* more-numbers)))
      (if (and (syntax-p number) (typep (reify number) '(cons (eql /))))
          (reflect (cadr (reify number)))
          (partial-funcall '/ number))))
(defun o:1+ (x) (o:+ 1 x))
(defun o:1- (x) (o:- x 1))
(defun o:abs (x) (partial-funcall 'abs x))
(defun o:mod (number divisor) (partial-funcall 'mod number divisor))
(defun o:floor (number &optional (divisor 1)) (partial-funcall 'floor number divisor))

(defun equality (source &rest args)
  (if (some #'syntax-p args)
      (let ((args (remove-duplicates (mapcar #'reify args) :test 'equal)))
        (if (cdr args) (reflect (list* source args) 'type 'boolean) t))
      (apply source args)))
(defun o:= (number &rest more-numbers)
  (apply #'equality '= number more-numbers))
(defun o:< (x y)
  (partial-funcall '< x y))
(defun o:> (x y) (o:< y x))
;;; List library
(defun o:length (list)
  (let ((type (get-layer list 'type)))
    (cond ((subtypep type 'cons)
           (o:1+ (o:length (o:cdr list))))
          (t (partial-funcall 'length list)))))

;;; Controls
(defun if-1 (condition true false)
  (if (syntax-p condition)
      (residual-funcall 'if condition (funcall true) (funcall false))
      (if condition (funcall true) (funcall false))))
(setf (get-hint 'if 'type)
      (lambda (condition true false)
        (declare (ignore condition))
        (sb-kernel:type-specifier (sb-kernel:specifier-type (list 'or (get-layer true 'type) (get-layer false 'type))))))
(defmacro o:if (condition true &optional false)
  `(if-1 ,condition (lambda () ,true) (lambda () ,false)))
(defmacro o:assert (test-form)
  `(partial-funcall 'assert-1 ',test-form ,test-form))
(defun assert-1 (info test)
  (unless test
    (error "The assertion ~a failed." info)))
(defun o:not (x) (partial-funcall 'not x))

;; hack CL macros
(defmacro o:and (&rest forms &environment env)
  (hack-macroexpand (cons 'and forms) env :scaena-cl))
(defmacro o:or (&rest forms &environment env)
  (hack-macroexpand (cons 'or forms) env :scaena-cl))
(defmacro o:cond (&rest clauses &environment env)
  (hack-macroexpand (cons 'cond clauses) env :scaena-cl))
